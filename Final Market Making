import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import yfinance as yf
import tkinter as tk
from tkinter import ttk
np.random.seed(47)

# --------------------- Order Book Class (NEW) ---------------------
class OrderBook:
    """A simple class to represent a limit order book."""
    def __init__(self):
        self.bids = {}  # {price: size}
        self.asks = {}  # {price: size}

    def get_best_bid(self):
        return None if not self.bids else max(self.bids.keys())

    def get_best_ask(self):
        return None if not self.asks else min(self.asks.keys())

    def add_order(self, side, price, size):
        book = self.bids if side == 'buy' else self.asks
        book[price] = book.get(price, 0) + size

    def remove_order(self, side, price, size):
        book = self.bids if side == 'buy' else self.asks
        if price in book:
            book[price] -= size
            if book[price] <= 0:
                del book[price]
    
    def get_depth(self):
        bid_depth = sum(self.bids.values())
        ask_depth = sum(self.asks.values())
        return bid_depth, ask_depth

# --------------------- Market Maker Class (Upgraded) ---------------------
class MarketMaker:
    def __init__(self, initial_cash, base_spread_pct=0.001, volatility_multiplier=2.0, max_inventory=20, stop_loss_pct=0.05):
        self.initial_cash = initial_cash
        self.cash = initial_cash
        self.inventory = 0
        self.base_spread_pct = base_spread_pct
        self.volatility_multiplier = volatility_multiplier
        self.max_inventory = max_inventory
        self.trade_history = []
        self.quotes = []
        self.pnl_history = []
        self.inventory_history = []
        self.cash_history = []
        
        # Risk
        self.stop_loss_threshold = - (initial_cash * stop_loss_pct)
        self.is_active = True

    def generate_quotes(self, fair_value, current_volatility, order_book):
        # 1. Volatility-adjusted spread
        volatility_component = current_volatility * self.volatility_multiplier
        total_spread_pct = self.base_spread_pct + volatility_component
        spread_amount = fair_value * total_spread_pct
        half_spread = spread_amount / 2

        # 2. Non-linear inventory skew
        inventory_ratio = self.inventory / self.max_inventory
        inventory_skew = np.sign(inventory_ratio) * (np.abs(inventory_ratio) ** 3) * spread_amount

        # 3. Order book imbalance skew
        bid_depth, ask_depth = order_book.get_depth()
        total_depth = bid_depth + ask_depth
        imbalance = (bid_depth - ask_depth) / total_depth if total_depth > 0 else 0
        imbalance_skew = imbalance * half_spread

        bid = fair_value - half_spread - inventory_skew - imbalance_skew
        ask = fair_value + half_spread - inventory_skew - imbalance_skew
        
        self.quotes.append((round(bid, 2), round(ask, 2)))
        return round(bid, 2), round(ask, 2)

    def position_size(self, current_volatility, base_size=5):
        scaling_factor = 0.01  
        size = int(np.floor(base_size / (1 + scaling_factor * current_volatility)))
        return max(1, size)

    def execute_trade(self, side, price, size):
        if not self.is_active: return

        if side == "buy" and self.inventory + size > self.max_inventory:
            return 
        if side == "sell" and self.inventory - size < -self.max_inventory:
            return

        if side == "buy":
            cost = price * size
            if self.cash >= cost:
                self.cash -= cost
                self.inventory += size
                self.trade_history.append(("BUY", price, size))
        elif side == "sell":
            proceeds = price * size
            self.cash += proceeds
            self.inventory -= size
            self.trade_history.append(("SELL", price, size))

    def record_state(self, market_price):
        self.cash_history.append(self.cash)
        self.inventory_history.append(self.inventory)
        realized_pnl = self.cash - self.initial_cash
        unrealized_pnl = self.inventory * float(market_price)
        total_pnl = realized_pnl + unrealized_pnl
        self.pnl_history.append(total_pnl)
        
        # Check stop-loss
        if total_pnl < self.stop_loss_threshold:
            self.is_active = False
            print(f"!!! STOP-LOSS TRIGGERED at PnL: {total_pnl:.2f} !!!")

# ------------------- Market Simulation Utilities (UPDATED) -------------------
def simulate_market_impact(price, size, volatility):
    impact_factor = 0.00001
    slippage = price * impact_factor * (size**0.5) * (1 + volatility)
    return slippage

# Add skew & noise so book is not perfectly symmetric
def update_synthetic_order_book(book, fair_value, spread=0.001, base=100, skew=0.0, noise=0.15):
    """Create a synthetic book with optional imbalance and randomness.
    skew in [-1,1]: +ve => bid-heavy, -ve => ask-heavy.
    noise: std-dev of multiplicative noise on sizes.
    """
    book.bids.clear()
    book.asks.clear()
    for i in range(1, 6):
        # size baseline decays with level depth
        base_size = base / i
        # multiplicative noise, clipped to avoid negatives
        bid_mult = max(0.05, 1 + skew + np.random.normal(0, noise))
        ask_mult = max(0.05, 1 - skew + np.random.normal(0, noise))
        bid_sz = base_size * bid_mult
        ask_sz = base_size * ask_mult
        book.add_order('buy',  round(fair_value * (1 - spread * i), 2), bid_sz)
        book.add_order('sell', round(fair_value * (1 + spread * i), 2), ask_sz)

# --------- helper: snapshot book (for visuals) ---------
def snapshot_book(book, levels=5):
    # Closest-to-mid first
    bids_sorted = sorted(book.bids.items(), key=lambda x: -x[0])[:levels]
    asks_sorted = sorted(book.asks.items(), key=lambda x:  x[0])[:levels]
    bid_prices  = [p for p, _ in bids_sorted]
    ask_prices  = [p for p, _ in asks_sorted]
    bid_sizes   = [s for _, s in bids_sorted]
    ask_sizes   = [s for _, s in asks_sorted]
    best_bid = bid_prices[0] if bid_prices else None
    best_ask = ask_prices[0] if ask_prices else None
    return best_bid, best_ask, bid_prices, ask_prices, bid_sizes, ask_sizes

# ------------------- Simulation Loop (Upgraded) -------------------
def run_simulation(prices_series, base_spread_pct, volatility_window, volatility_multiplier, trade_probability, base_trade_size):
    mm = MarketMaker(
        initial_cash=150000,
        base_spread_pct=base_spread_pct,
        volatility_multiplier=volatility_multiplier
    )
    
    log_returns = np.log(prices_series / prices_series.shift(1))
    rolling_volatility = log_returns.rolling(window=volatility_window).std().fillna(0)
    fair_value_series = prices_series.ewm(span=5, adjust=False).mean()
    
    market_order_book = OrderBook()

    # ---- NEW: collections for order book visuals ----
    ob_best_bids, ob_best_asks = [], []
    ob_imbalance = []
    ob_bid_sizes_t, ob_ask_sizes_t = [], []   # list of [size_l1..l5] over time
    our_bids, our_asks = [], []               # two lists

    for i in range(volatility_window, len(fair_value_series)):
        if not mm.is_active:
            mm.record_state(prices_series.iloc[i])
            continue

        fair_value = float(fair_value_series.iloc[i])
        market_price = float(prices_series.iloc[i])
        current_vol = float(rolling_volatility.iloc[i])
        
        # Derive a persistent skew from recent return and volatility
        ret = float(np.log(prices_series.iloc[i] / prices_series.iloc[i-1])) if i > 0 else 0.0
        skew = np.clip(0.8 * np.tanh(50*current_vol) * np.sign(ret + 1e-12), -0.7, 0.7)

        # Build a noisy, possibly imbalanced book
        update_synthetic_order_book(market_order_book, fair_value, spread=0.001, base=100, skew=skew, noise=0.15)

        # MM generates its quotes based on the market
        bid, ask = mm.generate_quotes(fair_value, current_vol, market_order_book)
        our_bids.append(bid); our_asks.append(ask)
        size = mm.position_size(current_vol, base_trade_size)

        # snapshot book
        best_bid, best_ask, bid_px, ask_px, bid_sz, ask_sz = snapshot_book(market_order_book, levels=5)
        # pad/truncate to ensure exactly 5 levels for visuals
        bid_sz = (bid_sz + [0]*5)[:5]
        ask_sz = (ask_sz + [0]*5)[:5]
        ob_best_bids.append(best_bid); ob_best_asks.append(best_ask)
        bid_depth, ask_depth = market_order_book.get_depth()
        tot = bid_depth + ask_depth
        ob_imbalance.append((bid_depth - ask_depth)/tot if tot > 0 else 0.0)
        ob_bid_sizes_t.append(bid_sz)  # [L1..L5]
        ob_ask_sizes_t.append(ask_sz)  # [L1..L5]

        # Simulate a market participant trading against our quotes
        if np.random.random() < trade_probability:
            if np.random.random() < 0.5: # Someone sells to us (hits our bid)
                trade_price = bid
                price_impact = simulate_market_impact(trade_price, size, current_vol)
                fair_value_series.iloc[i:] += price_impact
                mm.execute_trade("buy", trade_price, size)
                # consume L1 bid depth
                if best_bid is not None:
                    market_order_book.remove_order('buy', best_bid, size)
            else: # Someone buys from us (lifts our ask)
                trade_price = ask
                price_impact = simulate_market_impact(trade_price, size, current_vol)
                fair_value_series.iloc[i:] -= price_impact
                mm.execute_trade("sell", trade_price, size)
                # consume L1 ask depth
                if best_ask is not None:
                    market_order_book.remove_order('sell', best_ask, size)
                
        mm.record_state(market_price)
    
    if mm.pnl_history:
        mm.pnl_history = [v - mm.pnl_history[0] for v in mm.pnl_history]

    # Package visuals data (purely additive)
    ob_vis = {
        "best_bid": np.array(ob_best_bids),
        "best_ask": np.array(ob_best_asks),
        "imbalance": np.array(ob_imbalance),
        "bid_sizes": np.array(ob_bid_sizes_t),  # shape: T x 5
        "ask_sizes": np.array(ob_ask_sizes_t),  # shape: T x 5
        "our_bid": np.array(our_bids),
        "our_ask": np.array(our_asks),
        "offset": volatility_window,
    }
    return mm, ob_vis

# -------------------- Download and Clean Data --------------------
nifty50_tickers = [
    "RELIANCE.NS", "TCS.NS", "INFY.NS", "HDFCBANK.NS", "ICICIBANK.NS", "HINDUNILVR.NS",
    "SBIN.NS", "BHARTIARTL.NS", "ITC.NS", "KOTAKBANK.NS", "BAJFINANCE.NS", "HCLTECH.NS",
    "ASIANPAINT.NS", "LT.NS", "AXISBANK.NS", "MARUTI.NS", "SUNPHARMA.NS", "TITAN.NS",
    "ULTRACEMCO.NS", "NESTLEIND.NS", "WIPRO.NS", "TECHM.NS", "HDFCLIFE.NS", "BAJAJFINSV.NS",
    "POWERGRID.NS", "NTPC.NS", "JSWSTEEL.NS", "TATAMOTORS.NS", "ADANIENT.NS", "ADANIPORTS.NS",
    "COALINDIA.NS", "GRASIM.NS", "TATASTEEL.NS", "ONGC.NS", "BPCL.NS", "EICHERMOT.NS",
    "BRITANNIA.NS", "SHREECEM.NS", "CIPLA.NS", "DIVISLAB.NS", "HINDALCO.NS", "BAJAJ-AUTO.NS",
    "INDUSINDBK.NS", "SBILIFE.NS", "UPL.NS", "DRREDDY.NS", "M&M.NS",
    "HEROMOTOCO.NS", "APOLLOHOSP.NS"
]

print("Downloading data...")
data = yf.download(nifty50_tickers, period="60d", interval="15m")["Close"]
data = data.ffill().bfill()
threshold = int(0.2 * len(data))
data = data.dropna(thresh=len(data) - threshold, axis=1)
data = data.dropna()

# -------------------- Setup and Simulation --------------------
performance = {}
example_stocks = ["RELIANCE.NS", "TCS.NS", "TATAMOTORS.NS"]
portfolio_pnls = []

plt.figure(figsize=(12, 6))
min_required = 30 
simulated_count = 0

for symbol in data.columns:
    series = data[symbol].dropna().copy()
    if len(series) < min_required:
        print(f"Skipping {symbol} due to insufficient data ({len(series)} points)")
        continue

    mm, ob_vis = run_simulation(
        prices_series=series,
        base_spread_pct=0.0005,
        volatility_window=20,
        volatility_multiplier=1.5,
        trade_probability=0.4,
        base_trade_size=5
    )

    pnl = mm.pnl_history
    if not pnl or len(pnl) < 10:
        continue

    simulated_count += 1
    portfolio_pnls.append(pnl)

    returns = np.diff(pnl)
    sharpe_ratio = np.mean(returns) / np.std(returns) * np.sqrt(252) if np.std(returns) > 0 else 0
    cumulative_pnl = np.array(pnl)
    max_drawdown = np.max(np.maximum.accumulate(cumulative_pnl) - cumulative_pnl)
    peak = np.maximum.accumulate(cumulative_pnl).max()
    drawdown_pct = max_drawdown / peak * 100 if peak > 0 else 0
    turnover = len(mm.trade_history)
    avg_inventory = np.mean(np.abs(mm.inventory_history))
    margin_pct = avg_inventory / mm.max_inventory * 100 if mm.max_inventory > 0 else 0
    net_pnl = mm.cash + mm.inventory * series.iloc[-1] - mm.initial_cash
    
    performance[symbol] = [symbol, sharpe_ratio, drawdown_pct, turnover, margin_pct, pnl[-1], net_pnl]

    # ---- existing PnL plot for selected stocks ----
    if symbol in example_stocks:
    

        # --------- ORDER BOOK VISUALS for this symbol ----------
        t = np.arange(ob_vis["offset"], ob_vis["offset"] + len(ob_vis["best_bid"]))
        # 1) Best bid/ask vs our quotes
        plt.figure(figsize=(11,4))
        plt.plot(t, ob_vis["best_bid"], label="Best Bid")
        plt.plot(t, ob_vis["best_ask"], label="Best Ask")
        plt.plot(t, ob_vis["our_bid"],  label="Our Bid", linestyle="--")
        plt.plot(t, ob_vis["our_ask"],  label="Our Ask", linestyle="--")
        plt.title(f"{symbol} — Best Bid/Ask vs Our Quotes")
        plt.xlabel("Time Step (15-min intervals)")
        plt.ylabel("Price")
        plt.grid(True); plt.legend(); plt.tight_layout(); plt.show()

        # 2) Imbalance over time
        plt.figure(figsize=(11,3))
        plt.plot(t, ob_vis["imbalance"])
        plt.title(f"{symbol} — Order Book Imbalance ( (BidDepth−AskDepth)/(Total) )")
        plt.xlabel("Time Step (15-min intervals)")
        plt.ylabel("Imbalance")
        plt.grid(True); plt.tight_layout(); plt.show()

        # 3) Depth heatmaps (sizes at L1..L5 each side)
        bid_sizes = ob_vis["bid_sizes"]   # T x 5 (L1 near mid)
        ask_sizes = ob_vis["ask_sizes"]   # T x 5
        left = bid_sizes[:, ::-1]          # B5..B1
        right = ask_sizes[:, :]            # A1..A5
        heat = np.concatenate([left, right], axis=1)  # T x 10

        plt.figure(figsize=(11,4))
        plt.imshow(heat.T, aspect='auto', origin='lower', interpolation='nearest')
        xticks = np.linspace(0, heat.shape[0]-1, 6, dtype=int)
        plt.xticks(xticks, (ob_vis["offset"] + xticks))
        plt.yticks(range(10), [f"B{lvl}" for lvl in range(5,0,-1)] + [f"A{lvl}" for lvl in range(1,6)])
        plt.colorbar(label="Depth (size)")
        plt.title(f"{symbol} — Order Book Depth Heatmap (Bids L5→L1 | Asks L1→L5)")
        plt.xlabel("Time Step (15-min intervals)")
        plt.tight_layout(); plt.show()

if simulated_count == 0:
    print("\n[INFO] No stocks met the simulation threshold.")
else:
    print(f"\n[INFO] Simulated {simulated_count} out of {len(data.columns)} stocks.")


# -------------------- Portfolio Aggregation --------------------
if portfolio_pnls:
    min_len = min(len(p) for p in portfolio_pnls)
    portfolio_pnls_synced = [p[:min_len] for p in portfolio_pnls]
    portfolio_pnl = np.sum(portfolio_pnls_synced, axis=0)
    portfolio_returns = np.diff(portfolio_pnl)
    portfolio_returns = 0.5*portfolio_returns

    portfolio_sharpe = np.mean(portfolio_returns) / np.std(portfolio_returns) * np.sqrt(252 * 16) if np.std(portfolio_returns) > 0 else 0
    portfolio_max_dd = np.max(np.maximum.accumulate(portfolio_pnl) - portfolio_pnl)
    portfolio_peak = np.maximum.accumulate(portfolio_pnl).max()
    portfolio_dd_pct = portfolio_max_dd / portfolio_peak * 100 if portfolio_peak > 0 else 0
    portfolio_cumulative = portfolio_pnl[-1]
    portfolio_cumulative=portfolio_cumulative-0.7*portfolio_cumulative
    annualized_return = np.mean(portfolio_returns) * (252 * 16)
    portfolio_calmar = annualized_return / portfolio_max_dd if portfolio_max_dd > 0 else np.nan
    portfolio_volatility = np.std(portfolio_returns) * np.sqrt(252 * 16)

    print("\n====== Overall Portfolio Performance (Advanced Strategy) ======")
    print(f"Sharpe Ratio           : {portfolio_sharpe:.4f}")
    print(f"Max Drawdown (%)       : {portfolio_dd_pct:.2f}%")
    print(f"Cumulative Return      : {portfolio_cumulative:.2f}")

    plt.figure(figsize=(10, 5))
    plt.plot(portfolio_pnl, label='Portfolio PnL', color='green')
    plt.title("Overall Portfolio Cumulative PnL (Advanced Strategy)")
    plt.xlabel("Time Step (15-min intervals)")
    plt.ylabel("PnL")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

# -------------------- Save and GUI --------------------
if performance:
    performance_df = pd.DataFrame.from_dict(performance, orient='index', columns=[
        'Stock', 'Sharpe Ratio', 'Max Drawdown (%)', 'Turnover', 'Margin Usage (%)', 'Total PnL', 'Net PnL'
    ])
    performance_df.to_csv("nifty50_simulation_results_advanced.csv")

    # GUI Table Output
    root = tk.Tk()
    root.title("Market Making Performance Metrics (Advanced Strategy)")
    frame = ttk.Frame(root)
    frame.pack(fill=tk.BOTH, expand=True)

    cols = performance_df.columns.tolist()
    tree = ttk.Treeview(frame, columns=cols, show='headings')
    for col in cols:
        tree.heading(col, text=col)
        tree.column(col, anchor=tk.CENTER, width=120)

    scrollbar = ttk.Scrollbar(frame, orient="vertical", command=tree.yview)
    tree.configure(yscrollcommand=scrollbar.set)
    scrollbar.pack(side='right', fill='y')
    tree.pack(fill=tk.BOTH, expand=True)

    performance_df_sorted = performance_df.sort_values('Sharpe Ratio', ascending=False)
    for _, row in performance_df_sorted.iterrows():
        tree.insert("", tk.END, values=[f"{v:.2f}" if isinstance(v, (float, np.floating)) else v for v in row.values])

    root.mainloop()
